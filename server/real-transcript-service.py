#!/usr/bin/env python3
"""
Real transcript extraction service using multiple legitimate methods
This bypasses YouTube's cloud IP blocking by using alternative services
"""

import requests
import json
import re
import time
import random
from typing import Optional, List, Dict, Any
from urllib.parse import parse_qs, urlparse

class RealTranscriptService:
    def __init__(self):
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        })
    
    def extract_video_id(self, url: str) -> Optional[str]:
        """Extract YouTube video ID from URL"""
        patterns = [
            r'(?:youtube\.com/watch\?v=|youtu\.be/|youtube\.com/embed/)([^&\n?#]+)',
            r'(?:youtube\.com/v/)([^&\n?#]+)',
            r'(?:youtube\.com/embed/)([^&\n?#]+)',
        ]
        
        for pattern in patterns:
            match = re.search(pattern, url)
            if match:
                return match.group(1)
        
        # If it's already just a video ID
        if re.match(r'^[a-zA-Z0-9_-]{11}$', url):
            return url
            
        return None
    
    def get_transcript_via_youtube_dl(self, video_id: str) -> Optional[List[Dict[str, Any]]]:
        """Use youtube-dl to extract transcript"""
        try:
            import subprocess
            import tempfile
            import os
            
            # Create temp directory
            with tempfile.TemporaryDirectory() as temp_dir:
                # Try to download subtitles using yt-dlp
                cmd = [
                    'yt-dlp',
                    '--write-auto-sub',
                    '--write-sub',
                    '--sub-lang', 'en',
                    '--sub-format', 'vtt',
                    '--skip-download',
                    '--output', f'{temp_dir}/%(title)s.%(ext)s',
                    f'https://www.youtube.com/watch?v={video_id}'
                ]
                
                result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
                
                if result.returncode == 0:
                    # Look for subtitle files
                    for file in os.listdir(temp_dir):
                        if file.endswith('.vtt'):
                            with open(os.path.join(temp_dir, file), 'r', encoding='utf-8') as f:
                                content = f.read()
                                return self.parse_vtt_content(content)
                
        except Exception as e:
            print(f"yt-dlp extraction failed: {e}")
        
        return None
    
    def get_transcript_via_piped(self, video_id: str) -> Optional[List[Dict[str, Any]]]:
        """Use Piped API to extract transcript"""
        piped_instances = [
            "https://pipedapi.kavin.rocks",
            "https://piped-api.garudalinux.org",
            "https://api.piped.privacydev.net"
        ]
        
        for instance in piped_instances:
            try:
                url = f"{instance}/streams/{video_id}"
                response = self.session.get(url, timeout=15)
                
                if response.status_code == 200:
                    data = response.json()
                    
                    # Look for subtitles in the response
                    if 'subtitles' in data and data['subtitles']:
                        for subtitle in data['subtitles']:
                            if subtitle.get('autoGenerated', False):
                                continue  # Skip auto-generated
                            
                            sub_url = subtitle.get('url')
                            if sub_url:
                                return self.parse_subtitle_url(sub_url)
                                
            except Exception as e:
                print(f"Piped instance {instance} failed: {e}")
                continue
        
        return None
    
    def get_transcript_via_invidious(self, video_id: str) -> Optional[List[Dict[str, Any]]]:
        """Use Invidious instances to extract transcript"""
        invidious_instances = [
            "https://yewtu.be",
            "https://invidious.kavin.rocks",
            "https://invidious.io.lol",
            "https://vid.puffyan.us"
        ]
        
        for instance in invidious_instances:
            try:
                url = f"{instance}/api/v1/videos/{video_id}"
                response = self.session.get(url, timeout=15)
                
                if response.status_code == 200:
                    data = response.json()
                    
                    # Look for captions
                    if 'captions' in data:
                        for caption in data['captions']:
                            if caption.get('languageCode') == 'en':
                                caption_url = f"{instance}{caption['url']}"
                                return self.parse_subtitle_url(caption_url)
                                
            except Exception as e:
                print(f"Invidious instance {instance} failed: {e}")
                continue
        
        return None
    
    def parse_subtitle_url(self, url: str) -> Optional[List[Dict[str, Any]]]:
        """Parse subtitle content from URL"""
        try:
            response = self.session.get(url, timeout=15)
            if response.status_code == 200:
                content = response.text
                
                # Parse VTT format
                if 'WEBVTT' in content:
                    return self.parse_vtt_content(content)
                
                # Parse SRT format
                elif '-->' in content:
                    return self.parse_srt_content(content)
                
                # Parse XML format
                elif '<text' in content:
                    return self.parse_xml_content(content)
                    
        except Exception as e:
            print(f"Failed to parse subtitle URL: {e}")
        
        return None
    
    def parse_vtt_content(self, content: str) -> List[Dict[str, Any]]:
        """Parse VTT subtitle format"""
        transcript = []
        lines = content.split('\n')
        
        i = 0
        while i < len(lines):
            line = lines[i].strip()
            
            # Look for timestamp line
            if '-->' in line:
                timestamp_match = re.match(r'(\d+:\d+:\d+\.\d+)\s*-->\s*(\d+:\d+:\d+\.\d+)', line)
                if timestamp_match:
                    start_time = self.time_to_seconds(timestamp_match.group(1))
                    end_time = self.time_to_seconds(timestamp_match.group(2))
                    
                    # Get text from next lines
                    text_lines = []
                    i += 1
                    while i < len(lines) and lines[i].strip() and '-->' not in lines[i]:
                        text_lines.append(lines[i].strip())
                        i += 1
                    
                    if text_lines:
                        text = ' '.join(text_lines)
                        # Clean HTML tags
                        text = re.sub(r'<[^>]+>', '', text)
                        
                        transcript.append({
                            'text': text,
                            'start': start_time,
                            'duration': end_time - start_time
                        })
            else:
                i += 1
        
        return transcript
    
    def parse_srt_content(self, content: str) -> List[Dict[str, Any]]:
        """Parse SRT subtitle format"""
        transcript = []
        entries = re.split(r'\n\s*\n', content.strip())
        
        for entry in entries:
            lines = entry.strip().split('\n')
            if len(lines) >= 3:
                # Second line should be timestamp
                timestamp_line = lines[1]
                timestamp_match = re.match(r'(\d+:\d+:\d+,\d+)\s*-->\s*(\d+:\d+:\d+,\d+)', timestamp_line)
                
                if timestamp_match:
                    start_time = self.time_to_seconds(timestamp_match.group(1).replace(',', '.'))
                    end_time = self.time_to_seconds(timestamp_match.group(2).replace(',', '.'))
                    
                    # Rest are text lines
                    text = ' '.join(lines[2:])
                    text = re.sub(r'<[^>]+>', '', text)  # Remove HTML tags
                    
                    transcript.append({
                        'text': text,
                        'start': start_time,
                        'duration': end_time - start_time
                    })
        
        return transcript
    
    def parse_xml_content(self, content: str) -> List[Dict[str, Any]]:
        """Parse XML subtitle format"""
        transcript = []
        
        # Find all text elements
        text_elements = re.findall(r'<text start="([^"]+)"[^>]*>([^<]+)</text>', content)
        
        for start_str, text in text_elements:
            try:
                start_time = float(start_str)
                transcript.append({
                    'text': text.strip(),
                    'start': start_time,
                    'duration': 1.0  # Default duration
                })
            except ValueError:
                continue
        
        return transcript
    
    def time_to_seconds(self, time_str: str) -> float:
        """Convert time string to seconds"""
        try:
            # Handle format like "00:01:23.456"
            parts = time_str.split(':')
            if len(parts) == 3:
                hours = int(parts[0])
                minutes = int(parts[1])
                seconds = float(parts[2])
                return hours * 3600 + minutes * 60 + seconds
            elif len(parts) == 2:
                minutes = int(parts[0])
                seconds = float(parts[1])
                return minutes * 60 + seconds
            else:
                return float(time_str)
        except (ValueError, IndexError):
            return 0.0
    
    def get_real_transcript(self, video_id: str) -> Optional[List[Dict[str, Any]]]:
        """Get real transcript using multiple methods"""
        methods = [
            self.get_transcript_via_youtube_dl,
            self.get_transcript_via_piped,
            self.get_transcript_via_invidious,
        ]
        
        for method in methods:
            try:
                result = method(video_id)
                if result and len(result) > 0:
                    print(f"Successfully extracted transcript using {method.__name__}")
                    return result
                    
                # Add delay between attempts
                time.sleep(random.uniform(1, 3))
                
            except Exception as e:
                print(f"Method {method.__name__} failed: {e}")
                continue
        
        print(f"All transcript extraction methods failed for video {video_id}")
        return None

# Command line interface
if __name__ == "__main__":
    import sys
    
    if len(sys.argv) != 2:
        print("Usage: python real-transcript-service.py <video_id>")
        sys.exit(1)
    
    video_id = sys.argv[1]
    service = RealTranscriptService()
    
    transcript = service.get_real_transcript(video_id)
    
    if transcript:
        # Return JSON for Node.js to parse
        print(json.dumps(transcript))
    else:
        # Return empty array if no transcript found
        print(json.dumps([]))